#一、概述
&emsp;&emsp;关于JVM垃圾回收方面的东西从以下3个问题入手：
 * 哪些内存需要回收？
 * 怎么回收？
 * 什么时候回？
#二、哪些内存需要回收
##1、JAVA堆的回收
&emsp;&emsp;JAVA堆的回收就是对已经“死去”（不可能再被任何途径使用的对象）对象的回收。
但如何判断哪些对象“已死”。
###1.1、引用计数法
&emsp;&emsp;给对象添加一个引用计数器，每当有一个地方引用它就 +1，每当一个引用失效就 -1。
当计数器为零时则是不可能再被使用的状态。<br/>
&emsp;&emsp;优点：实现简单、判定效率高<br/>
&emsp;&emsp;缺点：无法解决相互循环引用的问题（对象A与对象B相互引用，除此之外不能其他地方引用）<br/>
###1.2、可达性分析算法
&emsp;&emsp;主流的商用语言（JAVA、C#等）中都是使用可达性分析来判定对象是否存活的。
这个算法的基本思路是，以一系列成为“GC Roots”的对象作为起点，从这些起点向下搜索，
搜索走过的路径被称为引用连（Reference Chain），当一个对象到GC Roots没有任何引用链相连时，则证明该对象是不可用的。<br/>
&emsp;&emsp;在JAVA中，可以被用来作为GC Roots的对象包含下面几种：
 * 虚拟机栈（栈帧中的本地变量表）中引用的对象
 * 方法区中静态属性引用的对象
 * 方法区中常量引用的对象
 * 本地方法栈中JNI（Native方法）引用的对象
 ###1.3、对象的引用
&emsp;&emsp;在JDK1.2以前，对象只存在被引用和没有被引用两种状态。单为了解决一些鸡肋对象的问题，在JDK1.2之后对引用的概念进行了扩充。
 * 强引用（Strong Reference）
&emsp;&emsp;类似"Object obj = new Object()"这类引用，只要这类引用还存在，垃圾收集器就永远不会回收被引用的对象。
 * 软引用（Soft Reference）
&emsp;&emsp;用来描述一些还有用但是并非必须的对象。
对于软引用关联的对象，在系统发生内存溢出之前会将这些对象列入回收范围之中进行第二次回收，如果第二次回收之后还是没有足够的内存才会抛出内存异常。
JDK1.2之后提供了SoftReference类来实现软引用。
 * 弱引用（Weak Reference）
&emsp;&emsp;也是用来描述非必须对象的，强度比软引用更弱一些。
被弱引用关联的对象只能生存到下一次垃圾收集发生之前，当垃圾回收时无论内存是否充足多会被回收掉。
使用WeakReference类来实现弱引用。 
 * 虚引用（Phantom Reference）
&emsp;&emsp;也被称为幽灵引用或者幻影引用。是最弱的一种引用关系。不会对对象的生存时间构成影响，也无法通过一个虚引用获取到一个对象的实例。
为一个对象设置虚引用关联的唯一目的就是能在这个对象被回收的时候收到一个系统通知。
使用PhantomReference来实现虚引用。
###1.4、对象是否真正死亡
&emsp;&emsp;宣告一个对象真正死亡至少需要两次标记过程。大致流程如下：
 * 经过可达性算法分支发现没有与GC Roots相连的引用链，被第一次标记并且进行第一次筛选。筛选的目的是判断是否有必要执行该对象的finalize（）方法。
 该对象没有重写finalize（）或者该对象的finalize（）方法已经被执行过一次，都被认为是没有必要执行。
 * 当被认为是有必要执行finalize（）方法，对象会被放到一个叫F-Queue的队列中，虚拟机会创建一个优先级低的线程去执行它，
 但不保证一定会被执行（finalize（）方法执行缓慢、发生死循环时其他finalize（）方法一种处于等待等）。当对象在finalize（）方法中与引用链关联上时，对象实现自救不会被回收（把自己赋值到静态变量等）。
 * 注意：finalize（）方法只会执行一次。
 * 注意：不鼓励使用这种方式来拯救对象。它运行代价高昂、不确定性大、无法保证对象的调用顺序。finalize（）能做的所有工作都能用其他方式实现，并且做的更好。
##2、方法区的回收
&emsp;&emsp;JAVA虚拟机规范中说过，可以不要求虚拟机在方法区中实现垃圾回收。在方法区中进行垃圾回收的“性价比低”，一般回收到的东西很少。<br/>
&emsp;&emsp;方法区的垃圾回收分为两个部分：废弃的常量和无用的类。
###2.1、废弃的常量
&emsp;&emsp;回收常量与回收JAVA堆中对象相似。以常量池中的字面量的回收为例，一个字符串“abc”进入了常量池，
但是没有任何地方引用常量池中的“abc”，如果这个时候发生内存回收，而且有必要的话，这个常量就会被系统清理出常量池。
常量池中的其他类（接口）、方法、字段的符号引用也类似。
###2.2、无用的类
&emsp;&emsp;判断一个类是否是无用的类需要满足下面3个条件：
 * 该类的所用实例都已经被回收（JAVA堆中不存在该类的任何实例）
 * 该类的ClassLoader已经被回收
 * 该类对应的java.long.Class对象没有在任何对方被引用，即无法在任何地方通过反射来访问该类的方法。
&emsp;&emsp;当满足上面3个条件的时候表明可以被回收，但并不是一定会被回收，虚拟机提供了参数配置来控制是否被回收，这里不进行详述。
但在大量使用反射、动态代理、CGLib等ByteCode框架、动态生成JSP以及OSGit这类频繁自定义ClassLoader的场景时需要虚拟机具备类卸载功能，以保证永久代不会溢出。
#三、怎么回收这些内存
##1、垃圾收集算法
###1.1、标记-清除算法
&emsp;&emsp;算法分为标记和清除两个阶段：首先标记出所哟需要回收的对象，在标记完成之后统一回收所有被标记的对象。
这个算法是最基础的收集算法，后续的算法都是基于这种思路改进其不足得到的。<br/>
这个算法主要有两个缺点：
 * 效率问题，标记和清除两个过程效率都不高。
 * 空间问题，标记清除之后会产生大量不连续的内存碎片，太多的空间碎片可能会导致在之后需要为较大的对象分配内存时没有足够的连续内存
 从而提前触发另一次垃圾收集动作。
###1.2、复制算法
&emsp;&emsp;复制算法解决了效率问题。将内存空间按容量分为大小相等的两块，每次只是用其中一块。当这一块内存使用完的时候，
将还存活的对象复制到另一块内存里边，然后将已使用过的内存空间一次清理掉。<br/>
&emsp;&emsp;这种算法不会产生内存碎片，并且实现简单、运行高效，但是使用内存缩小为了原来的一半。<br/>
&emsp;&emsp;目前商业的虚拟机都采用这种算法来回收新生代（Eden、Survivor了解一下）。
###1.3、标记-整理算法
&emsp;&emsp;复制算法在对象存活率较高的时候会进行较多的复制操作，效率会变低，并且还需要承担可用内存减半的代价。<br/>
&emsp;&emsp;在这种情况下，提出了一种“标记-整理算法”，标记的过程与标记清除算法一样，但后续不直接清除，
而是让所有存活的对象都向一端移动，然后清理掉端边界以外的内存。<br/>
&emsp;&emsp;适用于老年代的回收。
###1.4、分代收集算法
&emsp;&emsp;目前商业虚拟机都采用的算法。根据对象的存活周期不同将内存划分为几块（一般是把JAVA堆分为新生代和老年代），
然后根据各块内存中对象的特点采用不同的收集算法。
##2垃圾收集器
###2.1、Serial收集器
&emsp;&emsp;最基本发展历史最悠久的收集器。是一个单线程的收集器。曾经是年轻代收集器唯一的选择。
&emsp;&emsp;是虚拟机运行在Client模式下的默认的新生代的收集器。
###2.2、ParNew收集器
&emsp;&emsp;相当于Serial收集器的多线程版本。除了多线程意外与Serial收集没有太多的创新。
是运行在Server模式下的虚拟机中首选的新生代收集器。除了Serial之外，目前唯一能与CMS收集器配合工作的收集器。
###2.3、Parallel Scavenge收集器
&emsp;&emsp;Parallel Scavenge收集器是一个新生代收集器，使用的是复制算法，是一个多线程的收集器，通常被称为“吞吐量有先”收集器。
Parallel Scavenge收集器的目标是达到一个可控制的吞吐量（CPU用于运行用户代码的时间与CPU总消耗时间的比值）。
###2.4、Serial Old收集器
&emsp;&emsp;Serial Old事Serial收集器的老年代版本，是一个单线程收集器，使用的是“标记-整理算法”。该收集器的主要意义在于给Client模式下的虚拟机使用。
如果实在Server模式下，它有两大用途：1、JDK1.5及以前与Parallel Scavenge收集器搭配使用；
2、作为CMS收集器的后备预案，在并发收集发生Concurrent Mode Failure时使用。
###2.5、Parallel Old收集器
###2.6、CMS收集器
###2.7、G1收集器
&emsp;&emsp;
&emsp;&emsp;
&emsp;&emsp;