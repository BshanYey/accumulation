#一、概述
&emsp;&emsp;关于JVM垃圾回收方面的东西从以下3个问题入手：
 * 哪些内存需要回收？
 * 怎么回收？
 * 什么时候回？
#二、哪些内存需要回收
##1、JAVA堆的回收
&emsp;&emsp;JAVA堆的回收就是对已经“死去”（不可能再被任何途径使用的对象）对象的回收。
但如何判断哪些对象“已死”。
###1.1、引用计数法
&emsp;&emsp;给对象添加一个引用计数器，每当有一个地方引用它就 +1，每当一个引用失效就 -1。
当计数器为零时则是不可能再被使用的状态。<br/>
&emsp;&emsp;优点：实现简单、判定效率高<br/>
&emsp;&emsp;缺点：无法解决相互循环引用的问题（对象A与对象B相互引用，除此之外不能其他地方引用）<br/>
###1.2、可达性分析算法
&emsp;&emsp;主流的商用语言（JAVA、C#等）中都是使用可达性分析来判定对象是否存活的。
这个算法的基本思路是，以一系列成为“GC Roots”的对象作为起点，从这些起点向下搜索，
搜索走过的路径被称为引用连（Reference Chain），当一个对象到GC Roots没有任何引用链相连时，则证明该对象是不可用的。<br/>
&emsp;&emsp;在JAVA中，可以被用来作为GC Roots的对象包含下面几种：
 * 虚拟机栈（栈帧中的本地变量表）中引用的对象
 * 方法区中静态属性引用的对象
 * 方法区中常量引用的对象
 * 本地方法栈中JNI（Native方法）引用的对象
 ###1.3、对象的引用
&emsp;&emsp;在JDK1.2以前，对象只存在被引用和没有被引用两种状态。单为了解决一些鸡肋对象的问题，在JDK1.2之后对引用的概念进行了扩充。
 * 强引用（Strong Reference）
&emsp;&emsp;类似"Object obj = new Object()"这类引用，只要这类引用还存在，垃圾收集器就永远不会回收被引用的对象。
 * 软引用（Soft Reference）
&emsp;&emsp;用来描述一些还有用但是并非必须的对象。
对于软引用关联的对象，在系统发生内存溢出之前会将这些对象列入回收范围之中进行第二次回收，如果第二次回收之后还是没有足够的内存才会抛出内存异常。
JDK1.2之后提供了SoftReference类来实现软引用。
 * 弱引用（Weak Reference）
&emsp;&emsp;也是用来描述非必须对象的，强度比软引用更弱一些。
被弱引用关联的对象只能生存到下一次垃圾收集发生之前，当垃圾回收时无论内存是否充足多会被回收掉。
使用WeakReference类来实现弱引用。 
 * 虚引用（Phantom Reference）
&emsp;&emsp;也被称为幽灵引用或者幻影引用。是最弱的一种引用关系。不会对对象的生存时间构成影响，也无法通过一个虚引用获取到一个对象的实例。
为一个对象设置虚引用关联的唯一目的就是能在这个对象被回收的时候收到一个系统通知。
使用PhantomReference来实现虚引用。
###1.4、对象是否真正死亡
&emsp;&emsp;宣告一个对象真正死亡至少需要两次标记过程。大致流程如下：
 * 经过可达性算法分支发现没有与GC Roots相连的引用链，被第一次标记并且进行第一次筛选。筛选的目的是判断是否有必要执行该对象的finalize（）方法。
 该对象没有重写finalize（）或者该对象的finalize（）方法已经被执行过一次，都被认为是没有必要执行。
 * 当被认为是有必要执行finalize（）方法，对象会被放到一个叫F-Queue的队列中，虚拟机会创建一个优先级低的线程去执行它，
 但不保证一定会被执行（finalize（）方法执行缓慢、发生死循环时其他finalize（）方法一种处于等待等）。当对象在finalize（）方法中与引用链关联上时，对象实现自救不会被回收（把自己赋值到静态变量等）。
 * 注意：finalize（）方法只会执行一次。
 * 注意：不鼓励使用这种方式来拯救对象。它运行代价高昂、不确定性大、无法保证对象的调用顺序。finalize（）能做的所有工作都能用其他方式实现，并且做的更好。
##2、方法区的回收
&emsp;&emsp;JAVA虚拟机规范中说过，可以不要求虚拟机在方法区中实现垃圾回收。在方法区中进行垃圾回收的“性价比低”，一般回收到的东西很少。<br/>
&emsp;&emsp;方法区的垃圾回收分为两个部分：废弃的常量和无用的类。
###2.1、废弃的常量
&emsp;&emsp;回收常量与回收JAVA堆中对象相似。以常量池中的字面量的回收为例，一个字符串“abc”进入了常量池，
但是没有任何地方引用常量池中的“abc”，如果这个时候发生内存回收，而且有必要的话，这个常量就会被系统清理出常量池。
常量池中的其他类（接口）、方法、字段的符号引用也类似。
###2.2、无用的类
&emsp;&emsp;判断一个类是否是无用的类需要满足下面3个条件：
 * 该类的所用实例都已经被回收（JAVA堆中不存在该类的任何实例）
 * 该类的ClassLoader已经被回收
 * 该类对应的java.long.Class对象没有在任何对方被引用，即无法在任何地方通过反射来访问该类的方法。
&emsp;&emsp;当满足上面3个条件的时候表明可以被回收，但并不是一定会被回收，虚拟机提供了参数配置来控制是否被回收，这里不进行详述。
但在大量使用反射、动态代理、CGLib等ByteCode框架、动态生成JSP以及OSGit这类频繁自定义ClassLoader的场景时需要虚拟机具备类卸载功能，以保证永久代不会溢出。
#三、怎么回收这些内存
##1、垃圾收集算法
###1.1、标记-清除算法
&emsp;&emsp;算法分为标记和清除两个阶段：首先标记出所哟需要回收的对象，在标记完成之后统一回收所有被标记的对象。
这个算法是最基础的收集算法，后续的算法都是基于这种思路改进其不足得到的。<br/>
这个算法主要有两个缺点：
 * 效率问题，标记和清除两个过程效率都不高。
 * 空间问题，标记清除之后会产生大量不连续的内存碎片，太多的空间碎片可能会导致在之后需要为较大的对象分配内存时没有足够的连续内存
 从而提前触发另一次垃圾收集动作。
###1.2、复制算法
&emsp;&emsp;复制算法解决了效率问题。将内存空间按容量分为大小相等的两块，每次只是用其中一块。当这一块内存使用完的时候，
将还存活的对象复制到另一块内存里边，然后将已使用过的内存空间一次清理掉。<br/>
&emsp;&emsp;这种算法不会产生内存碎片，并且实现简单、运行高效，但是使用内存缩小为了原来的一半。<br/>
&emsp;&emsp;目前商业的虚拟机都采用这种算法来回收新生代（Eden、Survivor了解一下）。
###1.3、标记-整理算法
&emsp;&emsp;复制算法在对象存活率较高的时候会进行较多的复制操作，效率会变低，并且还需要承担可用内存减半的代价。<br/>
&emsp;&emsp;在这种情况下，提出了一种“标记-整理算法”，标记的过程与标记清除算法一样，但后续不直接清除，
而是让所有存活的对象都向一端移动，然后清理掉端边界以外的内存。<br/>
&emsp;&emsp;适用于老年代的回收。
###1.4、分代收集算法
&emsp;&emsp;目前商业虚拟机都采用的算法。根据对象的存活周期不同将内存划分为几块（一般是把JAVA堆分为新生代和老年代），
然后根据各块内存中对象的特点采用不同的收集算法。
##2垃圾收集器（需要review）
###2.1、Serial收集器
&emsp;&emsp;最基本发展历史最悠久的收集器。是一个单线程的收集器。曾经是年轻代收集器唯一的选择。
&emsp;&emsp;是虚拟机运行在Client模式下的默认的新生代的收集器。
###2.2、ParNew收集器
&emsp;&emsp;相当于Serial收集器的多线程版本。除了多线程意外与Serial收集没有太多的创新。
是运行在Server模式下的虚拟机中首选的新生代收集器。除了Serial之外，目前唯一能与CMS收集器配合工作的收集器。
###2.3、Parallel Scavenge收集器
&emsp;&emsp;Parallel Scavenge收集器是一个新生代收集器，使用的是复制算法，是一个多线程的收集器，通常被称为“吞吐量有先”收集器。
Parallel Scavenge收集器的目标是达到一个可控制的吞吐量（CPU用于运行用户代码的时间与CPU总消耗时间的比值）。
###2.4、Serial Old收集器
&emsp;&emsp;Serial Old事Serial收集器的老年代版本，是一个单线程收集器，使用的是“标记-整理算法”。该收集器的主要意义在于给Client模式下的虚拟机使用。
如果实在Server模式下，它有两大用途：1、JDK1.5及以前与Parallel Scavenge收集器搭配使用；
2、作为CMS收集器的后备预案，在并发收集发生Concurrent Mode Failure时使用。
###2.5、Parallel Old收集器
&emsp;&emsp;Parallel Scavenge收集器的老年代版本，使用多线程和“标记-整理算法”，在JDK1.6才开始提供。
###2.6、CMS收集器
&emsp;&emsp;CMS收集器时一种以获取最短回收停顿时间为目标的收集器。基于“标记-清除”算法实现，整个过程分为4个部分：
 * 初始标记
 * 并发标记
 * 重新标记
 * 并发清除
&emsp;&emsp;其中初始标记和重新标记两个步骤需要“Stop The World”。初始标记只是标记一下GC Roots能关联到的对象，
速度快。并发标记是进行GC Roots Tracing的过程。
重新标记是为了修正并发标记期间因用户程序继续运作而导致标记产生变动的那一部分对象的标记记录，这个阶段停顿的时间一般会比初始标记阶段稍长，
但远比并发标记的时间短。<br/>
&emsp;&emsp;由于耗时最长的并发标记和并发清除过程收集器可以和用户线程一起工作，所以总体来说CMS收集器的回收过程是与用户线程一起并发执行的。<br/>
&emsp;&emsp;优点：并发收集、低停顿<br/>
&emsp;&emsp;缺点：
 * CMS收集器对CPU资源敏感
 * CMS收集器无法处理浮动垃圾（Floating Garbage，并发清理阶段产生的新的垃圾，CMS无法在当次清理处理，只有留待下次处理的垃圾），
 可能出现“Concurrent Mode Failure”失败从而导致另一次Full GC的产生。
 * 使用的是“标记-清除”算法，会产生内存碎片。
###2.7、G1收集器
&emsp;&emsp;JDK1.7商用的用以替换CMS收集器的最前沿成果之一。<br/>
&emsp;&emsp;特点：
 * 并发收集
 * 分代收集，能独立管理整个GC
 * 空间整合，从整体来看G1收集器基于“标记-整理”算法，从局部（两个Region之间）来看是基于“复制”算法来实现的，所以不会产生内存碎片
 * 可预测的停顿
&emsp;&emsp;大致步骤：
 * 初始标记
 * 并发标记
 * 最终标记
 * 筛选回收
##3、GC日志
&emsp;&emsp;
##4、垃圾收集器参数
&emsp;&emsp;
#三、什么时候回收
&emsp;&emsp;简单的说就是年轻代、老年代、方法区垃圾回收的触发条件。
Minor GC：年轻代GC
Major GC：老年代GC
Full GC：同时清理年轻代和老年代
但是需要更深入的了解这些机制。
##1、内存分配与回收
###1.1、对象优先分配在Eden区域
&emsp;&emsp;大多数情况对象直接在新生代Eden中分配，当Eden区域没有足够的内存空间的时候会触发一次Minor GC。
###1.2、大对象直接进入老年代
&emsp;&emsp;这里的大对象指需要大量连续内存空间的对象（ps:很长的字符串、数组等）（ps2：代码里边要避免出现一群朝生夕死的大对象）。<br/>
&emsp;&emsp;虚拟机提供 -XX:PretenureSizeThreshold 参数，大于这个值得对象将直接分配到老年代。
&emsp;&emsp;ps：这样做的原因是避免在Eden和两个Survivor区域之间发生大量的内存复制（新生代采用的是复制算法）。
###1.3、长期存活的对象进入老年代
&emsp;&emsp;在Eden出生的对象，在经过一次Minor GC之后会被移动到Survivor区域并设定年龄为1，
对象在Survivor区域没经历过一次Minor GC年龄增加1，默认当年龄达到15时会被晋升到老年代中。
虚拟机提供参数 -XX:MaxTenuringThreshold 来设置晋升到老年代的阈值。
###1.4、动态年龄判定
&emsp;&emsp;当Survivor空间中相同年龄的所有对象之和大于Survivor空间的一半的时候，将年龄大于等于该年龄的对象全部晋升到老年代。
##2、分代回收
&emsp;&emsp;









