
---- 待完善

mysql
    Atomicity 原子性
    Consistency 一致性
    Isolation 隔离性（锁+MVCC）
    Durability 持久化
    
    
    原子性（Atomicity）
    原子性是指事务是一个不可分割的工作单位，事务中的操作要么都发生，要么都不发生。
    一致性（Consistency）
    事务前后数据的完整性必须保持一致。
    隔离性（Isolation）
    事务的隔离性是多个用户并发访问数据库时，数据库为每一个用户开启的事务，不能被其他事务的操作数据所干扰，多个并发事务之间要相互隔离。
    持久性（Durability）
    持久性是指一个事务一旦被提交，它对数据库中数据的改变就是永久性的，接下来即使数据库发生故障也不应该对其有任何影响

事务隔离级别
    读未提交    解决并发
    读已提交    解决脏读
    可重复读    解决不可重复度
    串行化      解决幻读

4个隔离级别和3个问题
    
    
    
mysql innodb对标准的支持
在innodb可重复读能解决幻读



innodb锁机制
共享锁（S锁） 多个事务可读不可改 代码后加 LOCK IN SHARE MODE
排它锁（X锁） 只有拥有锁的能读写  
        delete update insert 
        默认加上排它锁 
        代码后加 FOR UPDATE
        如果搜索的时候是按照索引来搜索的给搜索到的数据加行锁
        如果搜索的时候不是按照索引来搜索的 会加表锁
意向共享锁（IS锁）
    一个数据行加共享锁之前必须先取得IS锁，意向共享锁之间可以相互兼容
意向排它锁（IX锁）        
    一个数据行加排它锁之前必须先取得IX锁，意向排它锁之间可以相互兼容
    
意义：当事务想去进行锁表时，可以判断意向锁是否存在，存在时则可快速返回该表不能锁

临键锁（Next-key）（等于间隙锁 + 记录锁） (innodb 默认行锁算法)（可解决幻读）
    当sql执行按照索引进行数据检索时，
    且查询条件为范围查找时（between <  > ），
    且有数据命中时
    锁住
间隙锁（Grap Lock）（数据库 rr（读已提交？） 级别才会存在）
    临键锁基础上，当记录不存在时Next-key退化为间隙锁
记录锁（Record Lock）
    
注： 临键锁 间隙锁 记录锁 都是行锁的实现算法        
        

 死锁问题
 规避原则：
    1、添加合理索引（不添加可能是表锁，添加了可能是行锁）
    2、类似业务逻辑按照固定顺序访问表和行
    3、大事务拆小
    4、同一个事务中尽量一次锁定获取所有资源
    5、业务允许的情况下降低事务隔离级别
 
 解决死锁
 show engine innodb status; 打印出innodb最后一次产生死锁的日志。
       
        
        