

#索引
##1、概念
&emsp;&emsp;像一本字典，根据页码找到数据的，储存引擎用于快速找到记录的一种数据结构<br/>
&emsp;&emsp;索引类型有B+Tree、Hash索引、位图索引。其中B+Tree最常见
##2、B-Tree和B+Tree
&emsp;&emsp;B-Tree和B+Tree都是平衡多路查找树，B+Tree是B-Tree的升级版本。
###B-Tree
&emsp;&emsp;

###B+Tree
&emsp;&emsp;

###优缺点对比
&emsp;&emsp;
##几个问题
###索引再磁盘上是怎么储存的
###磁盘页是怎么载入数据库内存的
###为什么要使用B+Tree
###什么事聚簇索引，优缺点是什么

&emsp;&emsp;




#mysql四大特性
 * 原子性（Atomicity）<br/>
   原子性是指事务是一个不可分割的工作单位，事务中的操作要么都发生，要么都不发生。
 * 一致性（Consistency）<br/>
    事务前后数据的完整性必须保持一致。
 * 隔离性（Isolation）<br/>
    事务的隔离性是多个用户并发访问数据库时，数据库为每一个用户开启的事务，不能被其他事务的操作数据所干扰，多个并发事务之间要相互隔离。
 * 持久性（Durability）<br/>
    持久性是指一个事务一旦被提交，它对数据库中数据的改变就是永久性的，接下来即使数据库发生故障也不应该对其有任何影响
    
#4个隔离级别和3个问题
##事务并发带来的问题
 * 脏读（针对未提交的数据）：一个事务读到了另一个事务未提交的数据，一旦第二个事务回滚就会导致第一个事务读到的数据变成脏数据。
 * 不可重复度（读取数据本身的对比）：在同一事务内不同时间读取同一数据得到的结果不一致（其他事务对该数据做了修改）。
 * 幻读（读取结果集条数的对比）：一个事务按相同的查询条件查询之前检索过的数据，确发现检索出来的结果集条数变多或者减少（由其他事务插入、删除的）。
##隔离级别
 * 读未提交（READ UNCOMMITTED）    解决并发问题
 * 读已提交（READ COMMITTED）      解决脏读问题   
 * 可重复读（REPEATABLE READ）     解决不可重复度问题
 * 串行化（SERIALIZABLE）          解决幻读问题

mysql默认的事务隔离级别是 可重复读（REPEATABLE READ）<br/>
oracle只有读已提交和串行化两个级别，默认是 读已提交（READ COMMITTED） 

#innodb锁机制
&emsp;&emsp;innodb通过锁机制和mvcc来实现的事务隔离级别。innodb对标准的支持，在innodb可重复读能解决幻读（别的不行）。
##1、共享锁（S锁）
&emsp;&emsp;共享锁又称为读锁，简称S锁。多个事务对于同一数据可以共享一把锁，都能访问到数据，但是只能读不能修改。<br/>
&emsp;&emsp;理解：一个事务获取了一个数据行的共享锁，其他事务能获得该行对应的共享锁，但不能获得排他锁，
即一个事务在读取一个数据行的时候，其他事务也可以读，但不能对该数据行进行增删改(因为增删改都是自动加排它锁)。<br/>
&emsp;&emsp;实现：代码后加 LOCK IN SHARE MODE。
&emsp;&emsp;注意：共享锁都是行锁。
##2、排它锁（X锁） 
&emsp;&emsp;排他锁又称为写锁，简称X锁。排他锁不能与其他锁并存，如一个事务获取了一个数据行的排他锁，
其他事务就不能再获取该行的其他锁，包括共享锁和排他锁，但是获取排他锁的事务是可以对数据就行读取和修改。<br/>
&emsp;&emsp;理解：一个事务获取了一个数据行的排他锁，其他事务就不能再获取该行的其他锁（排他锁或者共享锁），
即一个事务在读取一个数据行的时候，其他事务不能对该数据行进行增删改，不加锁的查是可以的，加锁的查是不可以的。<br/>
&emsp;&emsp;注意：共享锁既可以是行锁也可以是表锁。如果搜索的时候是按照索引来搜索的给搜索到的数据加行锁，如果搜索的时候不是按照索引来搜索的会加表锁。<br/>
&emsp;&emsp;实现：delete、update、insert操作默认添加排它锁。手动添加：代码后加 FOR UPDATE
##注意
 * select默认不加锁
 * 一句话概括共享锁排它锁：S锁多事务可读，X锁一个事务读写
 
##3、意向共享锁（IS锁）
&emsp;&emsp;一个数据行加共享锁之前必须先取得IS锁，意向共享锁之间可以相互兼容
##4、意向排它锁（IX锁）        
&emsp;&emsp;一个数据行加排它锁之前必须先取得IX锁，意向排它锁之间可以相互兼容  
##意义：当事务想去进行锁表时，可以判断意向锁是否存在，存在时则可快速返回该表不能锁

##5、记录锁（Record Lock）
&emsp;&emsp;就是为某行记录加锁。<br/>
&emsp;&emsp;需要注意的是，查询条件必须是唯一索引或者主键列。否则会变成临健锁。
同时查询条件必须是精准匹配（=），不能是模糊匹配（模糊匹配会变成间隙锁或者临健锁）。<br/>
&emsp;&emsp;在通过"主键索引"与"唯一索引"对数据行进行 UPDATE 操作时，也会对该行数据加记录锁。
##6、临键锁（Next-key）（等于间隙锁 + 记录锁） (innodb 默认行锁算法)（可解决幻读）
&emsp;&emsp;临健锁可以解决幻读问题。
    有以下内容的一张表，表名t_test.
    
    id  name     age
    1   张三      1
    10  李四      10
    20  王五      20
    
&emsp;&emsp;以上表被分为了几个区间，分别是（-∞,1]、（1,10]、（10,20]、（20,+∞）。<br/>
&emsp;&emsp;当sql执行按照索引进行数据检索时，且查询条件为范围查找时（between <  > ），且有数据命中时，锁住查询所跨越的几个区间。
    
    SELECT * FROM t_test WHERE id > 1 AND id < 15 FOR UPDATE;
    会锁住（1,10]、(10,20]两个区间
    注意：SELECT * FROM t_test WHERE id > 1 AND id <= 10 FOR UPDATE;
    也会锁住（1,10]、(10,20]两个区间
    
##7、间隙锁（Grap Lock）（数据库 rr 级别才会存在）
&emsp;&emsp;临键锁基础上，当记录不存在时Next-key退化为间隙锁，锁住该范围内的一个开区间。在上面t_test表的基础上，有如下例子：

    SELECT * FROM t_test WHERE id > 1 AND id < 9 FOR UPDATE;
    会锁住区间(1,10)。// 测试时锁住了(1,10]

注： 临键锁 间隙锁 记录锁 都是行锁的实现算法        
        

##8、死锁问题
&emsp;&emsp;两个事务相互等待对方释放锁。
 * 规避原则：<br/>
    1、添加合理索引（不添加可能是表锁，添加了可能是行锁）<br/>
    2、类似业务逻辑按照固定顺序访问表和行<br/>
    3、大事务拆小<br/>
    4、同一个事务中尽量一次锁定获取所有资源<br/>
    5、业务允许的情况下降低事务隔离级别<br/>
 
 * 解决死锁<br/>
 show engine innodb status; 打印出innodb最后一次产生死锁的日志。
       
       
        