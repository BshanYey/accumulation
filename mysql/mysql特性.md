
---- 待完善

#mysql四大特性
 * 原子性（Atomicity）<br/>
   原子性是指事务是一个不可分割的工作单位，事务中的操作要么都发生，要么都不发生。
 * 一致性（Consistency）<br/>
    事务前后数据的完整性必须保持一致。
 * 隔离性（Isolation）<br/>
    事务的隔离性是多个用户并发访问数据库时，数据库为每一个用户开启的事务，不能被其他事务的操作数据所干扰，多个并发事务之间要相互隔离。
 * 持久性（Durability）<br/>
    持久性是指一个事务一旦被提交，它对数据库中数据的改变就是永久性的，接下来即使数据库发生故障也不应该对其有任何影响
    
#4个隔离级别和3个问题
##事务并发带来的问题
 * 脏读（针对未提交的数据）：一个事务读到了另一个事务未提交的数据，一旦第二个事务回滚就会导致第一个事务读到的数据变成脏数据。
 * 不可重复度（读取数据本身的对比）：在同一事务内不同时间读取同一数据得到的结果不一致（其他事务对该数据做了修改）。
 * 幻读（读取结果集条数的对比）：一个事务按相同的查询条件查询之前检索过的数据，确发现检索出来的结果集条数变多或者减少（由其他事务插入、删除的）。
##隔离级别
 * 读未提交（READ UNCOMMITTED）    解决并发问题
 * 读已提交（READ COMMITTED）      解决脏读问题   
 * 可重复读（REPEATABLE READ）     解决不可重复度问题
 * 串行化（SERIALIZABLE）          解决幻读问题

mysql默认的事务隔离级别是 可重复读（REPEATABLE READ）<br/>
oracle只有读已提交和串行化两个级别，默认是 读已提交（READ COMMITTED） 

#innodb锁机制
&emsp;&emsp;innodb通过锁机制和mvcc来实现的事务隔离级别。innodb对标准的支持，在innodb可重复读能解决幻读（别的不行）。



innodb锁机制
共享锁（S锁） 多个事务可读不可改 代码后加 LOCK IN SHARE MODE
排它锁（X锁） 只有拥有锁的能读写  
        delete update insert 
        默认加上排它锁 
        代码后加 FOR UPDATE
        如果搜索的时候是按照索引来搜索的给搜索到的数据加行锁
        如果搜索的时候不是按照索引来搜索的 会加表锁
意向共享锁（IS锁）
    一个数据行加共享锁之前必须先取得IS锁，意向共享锁之间可以相互兼容
意向排它锁（IX锁）        
    一个数据行加排它锁之前必须先取得IX锁，意向排它锁之间可以相互兼容
    
意义：当事务想去进行锁表时，可以判断意向锁是否存在，存在时则可快速返回该表不能锁

临键锁（Next-key）（等于间隙锁 + 记录锁） (innodb 默认行锁算法)（可解决幻读）
    当sql执行按照索引进行数据检索时，
    且查询条件为范围查找时（between <  > ），
    且有数据命中时
    锁住
间隙锁（Grap Lock）（数据库 rr（读已提交？） 级别才会存在）
    临键锁基础上，当记录不存在时Next-key退化为间隙锁
记录锁（Record Lock）
    
注： 临键锁 间隙锁 记录锁 都是行锁的实现算法        
        

 死锁问题
 规避原则：
    1、添加合理索引（不添加可能是表锁，添加了可能是行锁）
    2、类似业务逻辑按照固定顺序访问表和行
    3、大事务拆小
    4、同一个事务中尽量一次锁定获取所有资源
    5、业务允许的情况下降低事务隔离级别
 
 解决死锁
 show engine innodb status; 打印出innodb最后一次产生死锁的日志。
       
        
        